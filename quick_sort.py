"""
https://contest.yandex.ru/contest/23815/submits/
ПРИНЦИП РАБОТЫ
В программе реализован класс Participant, содержащий информацию о логине, числен решенных задач и штрафе.
Перечень участников соревнования представлен списком объектов класса Participant.
Сам алгоритм быстрой сортировки работает следующим образом:
1. Для списка вызываем функцию quicksort. Индексы элементов между которыми осуществляется сортировка
полагаем равными начальному и конечному индксам списка
2. Вызываем функцию поиска опорного элемента, которая основывается на работе двух указателей.
Индекс опорного элемента изначально совпадает с элементом, на который установлен левый указатель.
Создаем второй указатель, который пробегается по списку вправо.
Вызываем функцию сравнения объектов класса Participant, согласно установленным правилам.
Если i-й элемент больше начального, то индекс опорного элемента увеличивается, и i-й элемент меняется местами с опорным.
После пробегания списка начальный и опорный элементы меняются местами и функция возвращает индекс опорного элемента.
2. Осуществляется рекурсивный вызов quicksort для двух подчастей списка от стартового до опорного элемента и от опорного элемента
до конечного.
3. Алгоритм завершается при длине подчасти списка в 1 или менее элемент.

ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ
Из описания алгоритма следует, что нет расхода дополнительной памяти, как в случае обычной быстрой сортировки,
т.к. алгоритм рекурсивно обрабатывает не срезы списка а изначальный список, но в рамках начального и конечного индексов.
При этом элементы до опорного гарантированно больше него, что поддерживается свопами элементов при несоблюдении этого условия.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
В случае обратно отсортированного списка объектов алгоритм будет работать за O(N**2),т.к. опорный элемент будет на каждом шаге
делить список на часть, состоящую из одного элемента и часть, включающую все остальные.
В среднем случае если опорный элемент разбивает подчасть списка примерно пополам получим O(N * log N)

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Список содержит N объектов, занимает O(N) памяти.
Объект занимает O(K) памяти.
Стек функций занимает О(log N) памяти, где К-длина строки
Поэтому мой алгоритм будет требовать O(N) * О(log N) * O(K) = O(NKlogN) памяти.
"""


import sys
sys.setrecursionlimit(100000)


class Participant:
    def __init__(self, name, score, penalty):
        self.name = name
        self.score = score
        self.penalty = penalty

    def is_better_than(self, other):
        a = (-self.score, self.penalty, self.name)
        b = (-other.score, other.penalty, other.name)
        return a < b


def partition(array, begin, end):
    pivot_idx = begin
    for i in range(begin+1, end+1):
        if array[i].is_better_than(array[begin]):
            pivot_idx += 1
            array[i], array[pivot_idx] = array[pivot_idx], array[i]
    array[pivot_idx], array[begin] = array[begin], array[pivot_idx]
    return pivot_idx


def quicksort(array, begin, end):
    if begin >= end:
        return
    pivot_idx = partition(array, begin, end)
    quicksort(array, begin, pivot_idx-1)
    quicksort(array, pivot_idx+1, end)


def main():
    n = int(sys.stdin.readline().rstrip())
    objects_list = [0] * n

    for i in range(n):
        line = sys.stdin.readline().rstrip()
        obj = line.split()
        objects_list[i] = Participant(obj[0], int(obj[1]), int(obj[2]))

    quicksort(objects_list, 0, len(objects_list) - 1)
    for obj in objects_list:
        print(obj.name)


if __name__ == '__main__':
    main()
